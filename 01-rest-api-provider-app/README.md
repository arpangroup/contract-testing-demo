## Verify the provider
We will need to copy the Pact contract file that was produced from the consumer test into the Provider module. This will help us verify that the provider can meet the requirements as set out in the contract.

Now let's make a start on writing a Pact test to validate the consumer contract:

````java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@Provider("inventory-provider")
//@IgnoreNoPactsToVerify
@IgnoreMissingStateChange
public class InventoryProviderPactTest {
    @LocalServerPort
    private int port;

    @Autowired
    ProductRepository productRepository;

    @BeforeEach
    void before(PactVerificationContext context) {
        /* There are three main test targets you can use: HttpTestTarget, HttpsTestTarget and MessageTestTarget, PluginTestTarget. */
        context.setTarget(new HttpTestTarget("localhost", port));
        // context.setTarget(new MessageTestTarget());
    }

    @TestTemplate
    @ExtendWith(PactVerificationInvocationContextProvider.class)
    void pactVerificationTestTemplate(PactVerificationContext context) {
        context.verifyInteraction();
    }
}
````
This is a Springboot test that starts the app on a random port, and then injects the port into the test class. We then setup the test context using some annotations on the test class that tells the Pact framework who the provider is and where the pact files are. We also set the test target to point to the running app.

We now need to validate the pact generated by the consumer is valid by running the test, which should fail:
````
./mvnw verify

<<< Omitted >>>

1) Verifying a pact between ProductCatalogue and ProductService - get product with ID 10: has status code 200

    1.1) status: expected status of 200 but was 404

    1.2) body: $ Expected code='CC_001' but was missing

        {
        -  "code": "CC_001",
        -  "id": 10,
        -  "name": "28 Degrees",
        -  "type": "CREDIT_CARD",
        -  "version": "v1"
        +  "timestamp": "2021-02-26T02:50:41.293+00:00",
        +  "status": 404,
        +  "error": "Not Found",
        +  "message": "",
        +  "path": "/products/10"
        }

<<< Omitted >>>
````
The test has failed, as the expected path `/products/{id}` is returning 404. We incorrectly believed our provider was following a RESTful design, but the authors were too lazy to implement a better routing solution ü§∑üèª‚Äç‚ôÇÔ∏è.

The correct endpoint which the consumer should call is `/product/{id}`.



## Adding the missing states:
We need to update our provider code to deal with missing products and send a 404 response. However, our test data fixture also has product ID 10 and 11 in our database.

In this step, we will add some state handlers to our provider Pact verification test, which will update the state of our data store depending on which states the consumers require.

States are invoked prior to the actual test function is invoked. For each interaction in a pact file, the order of execution is as follows:

>BeforeEach -> StateHandler (setup) -> RequestFilter -> Execute Provider Test -> StateHandler (teardown) -> AfterEach

We're going to add handlers for all our states:
- products exist
- no products exist
- product with ID 10 exists
- product with ID 10 does not exist

Let's open up our provider Pact verification test in provider/src/test/java/io/pact/workshop/product_service/PactVerificationTest.java:

````java
  @State(value = "products exists", action = StateChangeAction.SETUP)
  void productsExists() {
    productRepository.deleteAll();
    productRepository.saveAll(Arrays.asList(
      new Product(100L, "Test Product 1", "CREDIT_CARD", "v1", "CC_001"),
      new Product(200L, "Test Product 2", "CREDIT_CARD", "v1", "CC_002"),
      new Product(300L, "Test Product 3", "PERSONAL_LOAN", "v1", "PL_001"),
      new Product(400L, "Test Product 4", "SAVINGS", "v1", "SA_001")
    ));
  }

  @State(value = "no products exists", action = StateChangeAction.SETUP)
  void noProductsExist() {
    productRepository.deleteAll();
  }

  @State(value = "product with ID 10 exists", action = StateChangeAction.SETUP)
  void productExists(Map<String, Object> params) {
    long productId = ((Number) params.get("id")).longValue();
    Optional<Product> product = productRepository.findById(productId);
    if (!product.isPresent()) {
      productRepository.save(new Product(productId, "Product", "TYPE", "v1", "001"));
    }
  }

  @State(value = "product with ID 10 does not exist", action = StateChangeAction.SETUP)
  void productNotExist(Map<String, Object> params) {
    long productId = ((Number) params.get("id")).longValue();
    Optional<Product> product = productRepository.findById(productId);
    if (product.isPresent()) {
      productRepository.deleteById(productId);
    }
  }
````

Let's see how we go now:
````
provider ‚ùØ ./mvnw verify

<<< Omitted >>>

[INFO] 
[INFO] Results:
[INFO] 
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0
[INFO] 
[INFO] 
[INFO] --- maven-jar-plugin:3.3.0:jar (default-jar) @ product-service ---
[INFO] Building jar: /home/ronald/Development/Projects/Pact/pact-workshop-Maven-Springboot-JUnit5/provider/target/product-service-1.0-SNAPSHOT.jar
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
````
NOTE: The states are not necessarily a 1 to 1 mapping with the consumer contract tests. You can reuse states amongst different tests. In this scenario we could have used no products exist for both tests which would have equally been valid.





Publish the Verification result:
````xml
<plugin>
  <groupId>au.com.dius.pact.consumer</groupId>
  <artifactId>pact-jvm-provider-maven-plugin</artifactId>
  <version>4.6.5</version> <!-- Use the latest version -->
  <executions>
    <execution>
      <goals>
        <goal>publishVerificationResults</goal>
      </goals>
      <configuration>
        <pactBrokerUrl>https://arpangroup.pactflow.io</pactBrokerUrl>
        <pactBrokerAuthenticationToken>pkqBnpXX3u4o5wErioDeXA</pactBrokerAuthenticationToken>
        <consumerVersion>1.0.0</consumerVersion> <!-- Use the version of your consumer -->
      </configuration>
    </execution>
  </executions>
</plugin>
````

